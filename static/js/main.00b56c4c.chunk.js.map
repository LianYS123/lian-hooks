{"version":3,"sources":["utils/index.js","service/index.js","demos/UseTableDemo.jsx","demos/UseTimerDemo.jsx","demos/UseMutationDemo.jsx","demos/UseDomDemo.jsx","demos/UseDragDemo.jsx","demos/UseDragableBox.jsx","App.js","index.js","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/hooks/useMutation.js","../../node_modules/lodash.throttle/index.js","../../node_modules/lodash.debounce/index.js","../../node_modules/fast-deep-equal/index.js","../../src/hooks/useUtils.js","../../src/hooks/useRequest.js","../../src/hooks/useTable.js","../../src/hooks/utils/dom.js","../../src/hooks/useDomHooks.js","../../src/hooks/useDrag.js","../../src/hooks/useDragableBox.js"],"names":["delay","t","Promise","resolve","setTimeout","times","fakeRequest","a","page","page_size","keyword","console","log","records","i","push","id","title","message","data","getAll","UseTableDemo","useState","showSelection","setShowSelection","disabledOdd","setDisabledOdd","type","setType","useTable","method","rowSelection","getCheckboxProps","record","disabled","tableProps","reload","search","style","margin","Item","label","onChange","checked","Group","value","ev","target","Button","onClick","Search","width","onSearch","rowKey","columns","dataIndex","UseTimerDemo","count1","setCount1","count2","setCount2","clearT","useTimeout","count","clearI","useInterval","UseMutationDemo","useMutation","load","loading","total","length","dataSource","defaultFormatter","UseDomDemo","divRef","useRef","bodyRef","document","documentElement","useSize","height","useEventListener","ref","Box","index","swapItem","color","getDragProps","useDrag","useDrop","onDrop","fromIndex","dropProps","isHovering","backgroundColor","textAlign","lineHeight","UseDragDemo","items","setItems","from","to","newItems","display","map","key","UseDragableBox","siderTarget","_width","useDragableBox","minWidth","maxWidth","defaultWidth","useThrottledValue","cursor","repeat","TabPane","Tabs","Object","entries","Demos","name","DemoComp","tab","ReactDOM","render","App","getElementById","Symbol","iterator","asyncIterator","_catch","body","recover","result","e","then","initialData","setLoading","error","setError","setData","methodRef","params","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","freeGlobal","global","freeSelf","self","root","Function","objectToString","prototype","toString","nativeMax","Math","max","nativeMin","min","now","Date","debounce","func","wait","options","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","undefined","apply","leadingEdge","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","remainingWait","debounced","isInvoking","arguments","this","toNumber","isObject","cancel","clearTimeout","flush","isObjectLike","call","isSymbol","other","valueOf","replace","isBinary","test","slice","equal","b","constructor","keys","Array","isArray","RegExp","source","flags","hasOwnProperty","interval","deps","timer","setTimer","funcRef","useEffect","I","setInterval","clearInterval","timeout","T","throttledValue","setValue","setThrottledValue","useCallback","throttle","useCustomCompareEffect","effect","compare","shouldUpdate","depsRef","useShouldUpdateEffect","useRequest","defaultParams","necessaryParams","ready","rest","_method","requestState","paramRef","necessaryParamsRef","loadData","_params","current","realParams","useDeepCompareEffect","defaultPageSize","formatter","customRowSelection","pageSize","onChangePaination","selectedRowKeys","setSelectedRowKeys","toCurrent","toPageSize","tempTotalPage","preserveSelectedRowKeys","selections","pagination","onShowSizeChange","getTargetElement","defaultElement","targetElement","eventName","listener","listenerRef","size","setSize","_setSize","window","defaultMouseAttribute","pageX","pageY","screenX","screenY","x","y","clientX","clientY","NaN","config","onDragStart","onDragEnd","draggable","JSON","setIsHovering","optionsRef","useMemo","onDragOver","err","onDragEnter","onDragLeave","attr","setAttr","useMouse","setWidth","isDragging","setIsDragging","box","left","newWidth"],"mappings":"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","file":"static/js/main.00b56c4c.chunk.js","sourcesContent":["export const delay = (t) => {\r\n  return new Promise((resolve) => setTimeout(resolve, t))\r\n}\r\n","import { delay } from 'utils'\r\n\r\nlet times = 0\r\n// \r\nexport const fakeRequest = async ({ page = 1, page_size = 10, keyword }) => {\r\n  if (times > 5) {\r\n    times = 0\r\n  }\r\n  console.log(page, page_size, keyword)\r\n  await delay(500)\r\n  const records = []\r\n  for (let i = (page - 1) * page_size + 1; i < page * page_size + 1; i++) {\r\n    records.push({\r\n      id: i,\r\n      title: `t${i}`,\r\n      message: `keyword: ${keyword}`\r\n    })\r\n  }\r\n  return {\r\n    data: records,\r\n    times: ++times\r\n  }\r\n}\r\n\r\nexport const getAll = async () => {\r\n  return await fakeRequest({ page: 1, page_size: 1000 })\r\n}\r\n","import React, { useState } from 'react';\r\n\r\nimport { useTable } from 'lian-hooks';\r\nimport { Table, Button, Input, Space, Switch, Form, Radio } from 'antd';\r\nimport { fakeRequest } from '../service';\r\n\r\n\r\nexport const UseTableDemo = () => {\r\n  const [showSelection, setShowSelection] = useState(false);\r\n  const [disabledOdd, setDisabledOdd] = useState(false);\r\n  const [type, setType] = useState('checkbox');\r\n\r\n  const { tableProps, reload, search } = useTable({\r\n    method: fakeRequest,\r\n    rowSelection: showSelection\r\n      ? {\r\n          type,\r\n          getCheckboxProps: record => ({\r\n            disabled: disabledOdd\r\n              ? record && record.id % 2 === 1\r\n                ? true\r\n                : false\r\n              : false,\r\n          }),\r\n        }\r\n      : false\r\n  });\r\n\r\n  const columns = [\r\n    {\r\n      dataIndex: 'title',\r\n      title: '标题',\r\n    },\r\n    {\r\n      dataIndex: 'message',\r\n      title: '信息',\r\n    },\r\n  ];\r\n\r\n  return (\r\n    <>\r\n      <Space style={{ margin: 16 }}>\r\n        <Form.Item label='show selection'>\r\n          <Switch onChange={checked => setShowSelection(checked)} />\r\n        </Form.Item>\r\n        <Form.Item label='type'>\r\n          <Radio.Group value={type} onChange={ev => setType(ev.target.value)}>\r\n            <Radio.Button value='radio'>Radio</Radio.Button>\r\n            <Radio.Button value='checkbox'>Checkbox</Radio.Button>\r\n          </Radio.Group>\r\n        </Form.Item>\r\n        <Form.Item label='disable odd'>\r\n          <Switch onChange={checked => setDisabledOdd(checked)} />\r\n        </Form.Item>\r\n      </Space>\r\n      <Space style={{ margin: 16 }}>\r\n        <Button onClick={() => reload()}>reload</Button>\r\n        <Input.Search\r\n          style={{ width: 200 }}\r\n          onSearch={keyword => search({ keyword })}\r\n        />\r\n      </Space>\r\n      <Table rowKey='id' columns={columns} {...tableProps} />\r\n    </>\r\n  );\r\n};\r\n","import React, { useState } from 'react';\r\nimport { useTimeout, useInterval } from 'lian-hooks';\r\nexport const UseTimerDemo = () => {\r\n  const [count1, setCount1] = useState(0);\r\n  const [count2, setCount2] = useState(0);\r\n\r\n  const clearT = useTimeout(() => {\r\n    console.log('timeout: ', count1);\r\n    setCount1(count => count + 1);\r\n  }, 1000);\r\n\r\n  const clearI = useInterval(() => {\r\n    console.log('interval', count2);\r\n    setCount2(count => count + 1);\r\n  }, 1000);\r\n\r\n  return (\r\n    <div>\r\n      timeout count1: {count1} <br />\r\n      interval count2: {count2} <br />\r\n      <button\r\n        onClick={() => {\r\n          clearI();\r\n          clearT();\r\n        }}\r\n      >\r\n        clear\r\n      </button>\r\n    </div>\r\n  );\r\n};\r\n","import React from 'react';\r\nimport { Button, Table, Space } from 'antd';\r\nimport { useMutation } from 'lian-hooks';\r\nimport { getAll } from '../service';\r\n\r\nconst defaultFormatter = ({ data = [] } = {}) => {\r\n  return { total: data.length, dataSource: data };\r\n};\r\n\r\nexport const UseMutationDemo = () => {\r\n  const [load, { loading, data }] = useMutation(getAll);\r\n\r\n  const tableProps = defaultFormatter(data);\r\n\r\n  const columns = [\r\n    {\r\n      dataIndex: 'title',\r\n      title: '标题',\r\n    },\r\n    {\r\n      dataIndex: 'message',\r\n      title: '信息',\r\n    },\r\n  ];\r\n\r\n  return (\r\n    <>\r\n      <Space style={{ margin: 16 }}>\r\n        <Button loading={loading} onClick={() => load()}>\r\n          load\r\n        </Button>\r\n      </Space>\r\n      <Table\r\n        loading={loading}\r\n        rowKey='id'\r\n        columns={columns}\r\n        {...tableProps}\r\n      />\r\n    </>\r\n  );\r\n};\r\n","import React, { useRef } from 'react';\r\nimport { useSize, useEventListener } from 'lian-hooks';\r\n\r\nexport const UseDomDemo = () => {\r\n  const divRef = useRef(null);\r\n  const bodyRef = useRef(document.documentElement);\r\n  const { width, height } = useSize(bodyRef);\r\n  useEventListener(divRef, 'click', () => {\r\n    console.log('test');\r\n  });\r\n  return (\r\n    <div ref={divRef}>\r\n      width: {width} <br />\r\n      height: {height} <br />\r\n    </div>\r\n  );\r\n};\r\n","import React, { useState } from 'react';\r\nimport { useDrag, useDrop } from 'lian-hooks';\r\n\r\nconst Box = ({ index, swapItem, color }) => {\r\n  const getDragProps = useDrag();\r\n\r\n  const [dropProps, { isHovering }] = useDrop({\r\n    onDrop: fromIndex => {\r\n      swapItem(fromIndex, index);\r\n    },\r\n  });\r\n\r\n  return (\r\n    <div\r\n      {...getDragProps(index)}\r\n      {...dropProps}\r\n      style={{\r\n        width: 100,\r\n        height: 100,\r\n        margin: 16,\r\n        backgroundColor: color,\r\n        textAlign: 'center',\r\n        lineHeight: '100px',\r\n      }}\r\n    >\r\n      box{index} {isHovering && 'release here!!!'}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport const UseDragDemo = () => {\r\n  const [items, setItems] = useState([\r\n    'red',\r\n    'blue',\r\n    'yellow',\r\n    'green',\r\n    'orange',\r\n  ]);\r\n\r\n  const swapItem = (from, to) => {\r\n    const newItems = [...items]; // 能否取到最新的items取决于如何调用此函数\r\n    [newItems[from], newItems[to]] = [items[to], items[from]];\r\n    setItems(newItems);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <div style={{ display: 'flex' }}>\r\n        {items.map((color, index) => (\r\n          <Box color={color} swapItem={swapItem} key={index} index={index} />\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n","import React, { useRef } from 'react';\r\nimport { useDragableBox, useThrottledValue } from 'lian-hooks';\r\n\r\nexport const UseDragableBox = () => {\r\n  const target = useRef();\r\n  const siderTarget = useRef();\r\n  const { width: _width } = useDragableBox({\r\n    minWidth: 100,\r\n    maxWidth: 400,\r\n    defaultWidth: 200,\r\n    target,\r\n    siderTarget,\r\n  });\r\n  const width = useThrottledValue(_width, 20);\r\n  return (\r\n    <>\r\n      <div style={{ display: 'flex' }}>\r\n        <div\r\n          ref={target}\r\n          style={{\r\n            width,\r\n            height: 200,\r\n            backgroundColor: 'skyblue',\r\n            // transition: 'width 100ms',\r\n          }}\r\n        ></div>\r\n        <div\r\n          ref={siderTarget}\r\n          style={{\r\n            width: 5,\r\n            height: 200,\r\n            backgroundColor: 'blue',\r\n            cursor: 'col-resize',\r\n          }}\r\n        ></div>\r\n      </div>\r\n      {'text'.repeat(100)}\r\n    </>\r\n  );\r\n};\r\n","import React from 'react';\r\nimport * as Demos from './demos';\r\nimport { Tabs } from 'antd';\r\n\r\nimport 'antd/dist/antd.css';\r\nimport './index.css';\r\n\r\nconst { TabPane } = Tabs;\r\n\r\nexport default () => {\r\n  return (\r\n    <div style={{ margin: 20 }}>\r\n      <Tabs>\r\n        {Object.entries(Demos).map(([name, DemoComp]) => {\r\n          return (\r\n            <TabPane tab={name} key={name}>\r\n              <DemoComp />\r\n            </TabPane>\r\n          );\r\n        })}\r\n      </Tabs>\r\n    </div>\r\n  );\r\n};\r\n","import './index.css'\r\n\r\nimport React from 'react'\r\nimport ReactDOM from 'react-dom'\r\nimport App from './App'\r\n\r\nReactDOM.render(<App />, document.getElementById('root'))\r\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { useState, useRef } from 'react';\r\n\r\n/**\r\n * @description: 异步方法的简单封装，处理请求的loading状态\r\n * @param {function} method 异步方法\r\n * @return {array} 异步方法和状态信息\r\n */\r\nexport const useMutation = (method, initialData) => {\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState();\r\n  const [data, setData] = useState(initialData);\r\n  const methodRef = useRef(method);\r\n  methodRef.current = method;\r\n\r\n  const loadData = async (...params) => {\r\n    try {\r\n      setLoading(true);\r\n      const res = await methodRef.current(...params);\r\n      setLoading(false);\r\n      setData(res);\r\n    } catch (e) {\r\n      setLoading(false);\r\n      setError(e);\r\n      // eslint-disable-next-line no-console\r\n      console.error(e);\r\n    }\r\n  };\r\n\r\n  return [loadData, { loading, error, data }];\r\n};\r\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = throttle;\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","import { useEffect, useState, useRef, useCallback } from 'react';\r\nimport throttle from 'lodash.throttle';\r\nimport debounce from 'lodash.debounce';\r\nimport isEqual from 'fast-deep-equal';\r\n\r\n/**\r\n * @description: setInterval的hooks实现\r\n * @param {function} func 要执行的函数\r\n * @param {number} interval 执行间隔\r\n * @param {Array} deps 依赖项\r\n * @return {*} clearInterval\r\n */\r\nexport const useInterval = (func, interval, deps = []) => {\r\n  const [timer, setTimer] = useState();\r\n  const funcRef = useRef(func);\r\n  funcRef.current = func; // 每次进入hooks保存最新的执行函数\r\n  const clear = () => clearInterval(timer);\r\n  useEffect(() => {\r\n    const I = setInterval(() => {\r\n      funcRef.current();\r\n    }, interval);\r\n    setTimer(I);\r\n    return () => clearInterval(I);\r\n  }, deps);\r\n  return clear;\r\n};\r\n\r\n/**\r\n * @description: setTimeout的hooks实现\r\n * @param {function} func 要执行的函数\r\n * @param {number} timeout 执行间隔\r\n * @param {Array} deps 依赖项\r\n * @return {*} clearTimeout\r\n */\r\nexport const useTimeout = (func, timeout, deps = []) => {\r\n  const [timer, setTimer] = useState();\r\n  const funcRef = useRef(func);\r\n  funcRef.current = func; // 每次进入hooks保存最新的执行函数\r\n  const clear = () => clearTimeout(timer);\r\n  useEffect(() => {\r\n    const T = setTimeout(funcRef.current, timeout);\r\n    setTimer(T);\r\n    return () => clearTimeout(T);\r\n  }, deps);\r\n  return clear;\r\n};\r\n\r\n/**\r\n * @description: 放缓获取value的速率（节流）\r\n * @param {*} value 要节流的值\r\n * @param {*} wait 节流时间间隔\r\n * @return {*} 放缓变化的值\r\n */\r\nexport const useThrottledValue = (value, wait = 100) => {\r\n  const [throttledValue, setValue] = useState();\r\n  const setThrottledValue = useCallback(throttle(setValue, wait), []);\r\n  useEffect(() => {\r\n    setThrottledValue(value);\r\n  }, [value]);\r\n  return throttledValue;\r\n};\r\n\r\n/**\r\n * @description: 合并一定时间内多次获取value的值（防抖）\r\n * @param {*} value 要节流的值\r\n * @param {*} wait 节流时间间隔\r\n * @return {*} 处理后的值\r\n */\r\nexport const useDebouncedValue = (value, wait = 100) => {\r\n  const [debouncedValue, setValue] = useState();\r\n  const setThrottledValue = useCallback(debounce(setValue, wait), []);\r\n  useEffect(() => {\r\n    setThrottledValue(value);\r\n  }, [value]);\r\n  return debouncedValue;\r\n};\r\n\r\n/**\r\n * @description: 自定义useEffect的更新逻辑\r\n * @param {*} effect 作用\r\n * @param {*} deps 依赖\r\n * @param {*} shouldUpdate 是否执行作用，返回true执行effect\r\n */\r\nexport const useShouldUpdateEffect = (effect, deps, shouldUpdate) => {\r\n  const depsRef = useRef(deps);\r\n  if (shouldUpdate(depsRef.current, deps)) {\r\n    depsRef.current = deps;\r\n  }\r\n  useEffect(effect, depsRef.current);\r\n};\r\n\r\n/**\r\n * @description: 自定义useEffect的依赖比较逻辑\r\n * @param {*} effect 作用\r\n * @param {*} deps 依赖\r\n * @param {*} compare 自定义比较函数\r\n */\r\nexport const useCustomCompareEffect = (effect, deps, compare) =>\r\n  useShouldUpdateEffect(effect, deps, (...args) => !compare(...args));\r\n\r\n/**\r\n * @description: 使用深比较的useEffect\r\n * @param {*} effect 作用\r\n * @param {*} deps 依赖\r\n * @return {*}\r\n */\r\nexport const useDeepCompareEffect = (effect, deps = []) => {\r\n  return useCustomCompareEffect(effect, deps, isEqual);\r\n};\r\n\r\n/**\r\n * @description: 获取上一个值\r\n * @param {*} state 当前值\r\n * @param {*} compare 比较函数, 返回true时更新上一个值，默认每次渲染都更新\r\n * @return {*} 前一个值\r\n */\r\nexport const usePrevious = (state, compare) => {\r\n  const prevRef = useRef();\r\n  const curRef = useRef(state);\r\n  const shouldUpdate =\r\n    typeof compare === 'function' ? compare(curRef.current, state) : true;\r\n  if (shouldUpdate) {\r\n    prevRef.current = curRef.current;\r\n    curRef.current = state;\r\n  }\r\n  return prevRef.current;\r\n};\r\n/**\r\n * @description: 组件更新时执行的事件\r\n * @param {*} fn  要执行的函数\r\n * @param {*} deps  依赖项\r\n */\r\nexport const useUpdateEffect = (fn, deps) => {\r\n  const isMouted = useRef(false);\r\n  useEffect(() => {\r\n    if (isMouted.current) {\r\n      return fn();\r\n    } else {\r\n      isMouted.current = true;\r\n    }\r\n  }, deps);\r\n};\r\n\r\n/**\r\n * @description: 组件卸载时执行的操作\r\n * @param {function} fn 操作函数\r\n */\r\nexport const useUnmount = (fn) => {\r\n  const fnRef = useRef(fn);\r\n  fnRef.current = fn;\r\n  useEffect(() => {\r\n    return fnRef.current;\r\n  }, []);\r\n};\r\n\r\n/**\r\n * @description: 获取组件卸载状态\r\n * @return {*}: 组件是否已卸载\r\n */\r\nexport const useIsUnmounted = () => {\r\n  const isUnmountedRef = useRef(false);\r\n  isUnmountedRef.current = false;\r\n  useUnmount(() => {\r\n    isUnmountedRef.current = true;\r\n  });\r\n  return isUnmountedRef.current;\r\n};\r\n\r\n/**\r\n * @description: 获取组件卸载状态\r\n * @return {*}: 组件是否已挂载\r\n */\r\nexport const useIsMounted = () => !useIsUnmounted();\r\n\r\n// hooks中打印信息\r\nexport const useLog = (...args) => {\r\n  useEffect(() => {\r\n    console.log(...args);\r\n  }, args);\r\n};\r\n\r\n// useFlag\r\nexport const useFlag = () => {\r\n  const [flag, setFlag] = useState(false);\r\n  const setTrue = () => setFlag(true);\r\n  const setFalse = () => setFlag(false);\r\n  const toggle = () => setFlag((f) => !f);\r\n  return {\r\n    flag,\r\n    setTrue,\r\n    setFalse,\r\n    toggle\r\n  };\r\n};\r\n","import { useRef } from 'react';\r\nimport { useMutation } from './useMutation';\r\nimport { useDeepCompareEffect } from './useUtils';\r\n\r\n/**\r\n * @description: 请求方法的简单封装，处理请求的loading状态\r\n * @param {object} options 配置\r\n * @param {*} options.method 请求方法\r\n * @param {*} options.defaultParams 默认参数\r\n * @param {*} options.necessaryParams 必要参数\r\n * @param {*} options.ready === true时发起请求，默认值为true\r\n * @param {*} options.initialData 初始数据\r\n * @param {*} options.rest 请求方法额外参数, onError事件等options可以通过这个参数传递\r\n */\r\nexport const useRequest = (options) => {\r\n  const {\r\n    method,\r\n    defaultParams = {},\r\n    necessaryParams,\r\n    ready = true,\r\n    initialData,\r\n    ...rest\r\n  } = options;\r\n  const [_method, requestState] = useMutation(method, initialData);\r\n  const paramRef = useRef(defaultParams);\r\n  const necessaryParamsRef = useRef(necessaryParams);\r\n  necessaryParamsRef.current = necessaryParams;\r\n\r\n  const loadData = (_params = paramRef.current) => {\r\n    paramRef.current = _params;\r\n    if (!requestState.loading) {\r\n      const realParams = { ...necessaryParamsRef.current, ..._params }; // 每次请求都带上necessaryParams\r\n      _method(realParams, rest);\r\n    }\r\n  };\r\n\r\n  // 使用上次的参数重新请求\r\n  const reload = () => {\r\n    loadData();\r\n  };\r\n\r\n  useDeepCompareEffect(() => {\r\n    if (ready === true) {\r\n      loadData();\r\n    }\r\n  }, [necessaryParams, ready]);\r\n\r\n  return {\r\n    search: loadData,\r\n    reload,\r\n    params: { ...necessaryParamsRef.current, ...paramRef.current },\r\n    ...requestState\r\n  };\r\n};\r\n","import { useState } from 'react';\r\nimport { useRequest } from './useRequest';\r\n\r\nconst defaultFormatter = ({ data = [] } = {}) => {\r\n  return { total: data.length, dataSource: data };\r\n};\r\n\r\n/**\r\n * @description: 封装方便antd table使用的hooks\r\n * @param options 配置信息\r\n */\r\nconst useTable = (options) => {\r\n  const {\r\n    method, // 请求方法\r\n    defaultPageSize = 10, // 默认分页大小, 不传默认为10\r\n    necessaryParams = {}, // 必要请求参数\r\n    formatter = defaultFormatter, // 请求结果数据转换函数, 返回{total, dataSource}\r\n    rowSelection: customRowSelection, // 选项框属性，为true时展示默认选项框\r\n    ...rest // 默认请求参数等\r\n  } = options;\r\n  const [\r\n    { current = 1, pageSize = defaultPageSize },\r\n    onChangePaination\r\n  ] = useState({ current: 1, pageSize: defaultPageSize });\r\n  const [selectedRowKeys, setSelectedRowKeys] = useState([]);\r\n\r\n  const realParams = {\r\n    ...necessaryParams,\r\n    page: current,\r\n    page_size: pageSize\r\n  };\r\n\r\n  const { data, loading, search, reload } = useRequest({\r\n    method,\r\n    necessaryParams: realParams,\r\n    ...rest\r\n  });\r\n\r\n  const { total, dataSource } = formatter(data);\r\n\r\n  const onChange = (current, pageSize) => {\r\n    let toCurrent = current <= 0 ? 1 : current;\r\n    const toPageSize = pageSize <= 0 ? 1 : pageSize;\r\n    const tempTotalPage = Math.ceil(total / toPageSize);\r\n\r\n    if (tempTotalPage && toCurrent > tempTotalPage) {\r\n      toCurrent = tempTotalPage;\r\n    }\r\n\r\n    onChangePaination({\r\n      current: toCurrent,\r\n      pageSize: toPageSize\r\n    });\r\n  };\r\n  const rowSelection = customRowSelection || {\r\n    onChange: (selectedRowKeys) => {\r\n      setSelectedRowKeys(selectedRowKeys);\r\n    },\r\n    selectedRowKeys,\r\n    preserveSelectedRowKeys: true,\r\n    selections: false\r\n  };\r\n\r\n  if (customRowSelection && typeof customRowSelection === 'object') {\r\n    Object.assign(rowSelection, customRowSelection);\r\n  }\r\n\r\n  const pagination = {\r\n    current,\r\n    pageSize,\r\n    total,\r\n    onChange: onChange,\r\n    onShowSizeChange: onChange\r\n  };\r\n\r\n  return {\r\n    loading,\r\n    data,\r\n    reload,\r\n    search,\r\n    pagination,\r\n    tableProps: {\r\n      dataSource,\r\n      loading,\r\n      pagination,\r\n      rowSelection\r\n    }\r\n  };\r\n};\r\n\r\nexport { useTable };\r\n","export function getTargetElement(target, defaultElement) {\r\n  if (!target) {\r\n    return defaultElement;\r\n  }\r\n\r\n  let targetElement;\r\n\r\n  if (typeof target === 'function') {\r\n    targetElement = target();\r\n  } else if ('current' in target) {\r\n    targetElement = target.current;\r\n  } else {\r\n    targetElement = target;\r\n  }\r\n\r\n  return targetElement;\r\n}\r\n","import { useState, useEffect, useRef } from 'react';\r\nimport { getTargetElement } from './utils/dom';\r\n\r\n/**\r\n * @description: 在hooks中使用事件监听器\r\n * @param {*} target  dom对象或其ref引用\r\n * @param {*} eventName 事件名称\r\n * @param {*} listener  事件监听器\r\n */\r\nexport const useEventListener = (target, eventName, listener) => {\r\n  const listenerRef = useRef(listener);\r\n  listenerRef.current = listener;\r\n  useEffect(() => {\r\n    const targetElement = getTargetElement(target, window); // 放里面，不然targetElement会被缓存\r\n    if (!targetElement?.addEventListener) {\r\n      return;\r\n    }\r\n    targetElement.addEventListener(eventName, listenerRef.current);\r\n    return targetElement.removeEventListener.bind(\r\n      targetElement,\r\n      eventName,\r\n      listenerRef.current\r\n    );\r\n  }, [eventName, target]);\r\n};\r\n\r\n/**\r\n * @description: 监听元素大小变化\r\n * @param ref 元素ref引用\r\n * @return {*} {width, height}\r\n */\r\nexport const useSize = (ref) => {\r\n  const [size, setSize] = useState({\r\n    width: 0,\r\n    height: 0\r\n  });\r\n  const _setSize = () => {\r\n    setSize({\r\n      width: ref.current ? ref.current.clientWidth : 0,\r\n      height: ref.current ? ref.current.clientHeight : 0\r\n    });\r\n  };\r\n  useEventListener(window, 'resize', _setSize);\r\n  useEffect(() => {\r\n    _setSize();\r\n  }, []);\r\n  return size;\r\n};\r\n\r\nconst defaultMouseAttribute = {\r\n  pageX: NaN,\r\n  pageY: NaN,\r\n  screenX: NaN,\r\n  screenY: NaN,\r\n  x: NaN,\r\n  y: NaN,\r\n  clientX: NaN,\r\n  clientY: NaN\r\n};\r\n\r\n/**\r\n * @description: 获取鼠标位置信息\r\n * @return {*} 鼠标位置信息\r\n */\r\nexport const useMouse = () => {\r\n  const [attr, setAttr] = useState(defaultMouseAttribute);\r\n  useEventListener(window, 'mousemove', (ev) => {\r\n    const { pageX, pageY, screenX, screenY, x, y, clientX, clientY } = ev;\r\n    setAttr({ pageX, pageY, screenX, screenY, x, y, clientX, clientY });\r\n  });\r\n  return attr;\r\n};\r\n","import { useRef, useState, useMemo } from 'react';\r\n\r\n/**\r\n * @description: 获取可以被拖拽的元素属性\r\n * @param {Object} config 拖拽开始执行的函数, 拖拽结束执行的函数\r\n * @return {*} 一个获取拖拽属性的函数，入参为拖拽传输的数据\r\n */\r\nexport const useDrag = (config = {}) => {\r\n  const { onDragStart, onDragEnd } = config;\r\n  return (data) => ({\r\n    draggable: 'true',\r\n    key: JSON.stringify(data),\r\n    onDragStart: (ev) => {\r\n      ev.dataTransfer.setData('custom', JSON.stringify(data));\r\n      onDragStart && onDragStart(data, ev);\r\n    },\r\n    onDragEnd: (ev) => {\r\n      onDragEnd && onDragEnd(data, ev);\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * @description: 获取接收被拖拽内容的元素的属性\r\n * @return {*} 释放元素属性\r\n */\r\nexport const useDrop = (options) => {\r\n  const [isHovering, setIsHovering] = useState(false);\r\n  const optionsRef = useRef(options);\r\n  optionsRef.current = options; // 保证每次执行的函数都是最新的\r\n  const props = useMemo(\r\n    () => ({\r\n      onDragOver: (ev) => {\r\n        ev.preventDefault(); // 必须禁用默认事件\r\n      },\r\n      onDrop: (ev) => {\r\n        ev.preventDefault();\r\n        ev.persist();\r\n        setIsHovering(false);\r\n        let data = ev.dataTransfer.getData('custom');\r\n        try {\r\n          data = JSON.parse(data);\r\n        } catch (err) {}\r\n        optionsRef.current.onDrop(data, ev);\r\n      },\r\n      onDragEnter: (ev) => {\r\n        ev.preventDefault();\r\n        setIsHovering(true);\r\n      },\r\n      onDragLeave: (ev) => {\r\n        ev.preventDefault();\r\n        setIsHovering(false);\r\n      }\r\n    }),\r\n    [setIsHovering]\r\n  );\r\n  return [props, { isHovering }];\r\n};\r\n","import { useState, useEffect } from 'react';\r\nimport { useMouse, useEventListener } from './useDomHooks';\r\nimport { getTargetElement } from './utils/dom';\r\n\r\n/**\r\n * @description: 拉伸容器\r\n * @param {object} options\r\n * @param {number} options.defaultWidth 默认宽度\r\n * @param {number} options.minWidth 最小宽度\r\n * @param {number} options.maxWidth 最大宽度\r\n * @param {*} options.target 被拉伸的容器\r\n * @param {*} options.siderTarget 用于拉伸的边缘\r\n * @return {object} 包含宽度和拖拽状态的对象\r\n */\r\nexport const useDragableBox = (options) => {\r\n  const { defaultWidth, minWidth, maxWidth, target, siderTarget } = options;\r\n  const { clientX } = useMouse();\r\n  const [width, setWidth] = useState(defaultWidth);\r\n  const [isDragging, setIsDragging] = useState(false);\r\n  useEffect(() => {\r\n    const box = getTargetElement(target);\r\n    if (!box.getBoundingClientRect) {\r\n      return;\r\n    }\r\n    const { left } = box.getBoundingClientRect() || {};\r\n    let newWidth = clientX - left;\r\n    newWidth = Math.max(minWidth, newWidth);\r\n    newWidth = Math.min(maxWidth, newWidth);\r\n    if (isDragging && width !== newWidth) {\r\n      setWidth(newWidth);\r\n    }\r\n  }, [target, clientX, isDragging, maxWidth, minWidth, setWidth, siderTarget]);\r\n  useEffect(() => {\r\n    document.body.style.cursor = isDragging ? 'col-resize' : '';\r\n    document.onselectstart = () => !isDragging;\r\n    return () => {\r\n      document.body.style.cursor = '';\r\n      document.onselectstart = null;\r\n    };\r\n  }, [isDragging]);\r\n  useEventListener(window, 'mouseup', () => {\r\n    setIsDragging(false);\r\n  });\r\n  useEventListener(siderTarget, 'mousedown', () => {\r\n    setIsDragging(true);\r\n  });\r\n  return { width, isDragging };\r\n};\r\n"],"sourceRoot":""}